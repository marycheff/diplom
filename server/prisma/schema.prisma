generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model User {
  id             String        @id @default(auto()) @map("_id") @db.ObjectId
  email          String        @unique @map("email")
  name           String?       @map("name")
  surname        String?       @map("surname")
  patronymic     String?       @map("patronymic")
  password       String        @map("password")
  isActivated    Boolean       @default(false) @map("is_activated")
  role           Role          @default(USER) @map("role")
  activationLink String?       @map("activation_link")
  resetCode      String?       @map("reset_code")
  isBlocked      Boolean       @default(false) @map("is_blocked")
  refreshToken   Token?        @relation("UserToken")
  testsCreated   Test[]        @relation("TestAuthor")
  testAttempts   TestAttempt[] @relation("TestAttemptUser")
  badWordsAdded  BadWord[]     @relation("AddedByUser")
  createdAt      DateTime      @default(now()) @map("created_at")
  updatedAt      DateTime      @updatedAt @map("updated_at")

  @@map("users")
}

model Token {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  userId       String   @unique @map("user_id") @db.ObjectId
  user         User     @relation("UserToken", fields: [userId], references: [id])
  refreshToken String   @unique @map("refresh_token")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  @@map("tokens")
}

model TestSettings {
  id                  String   @id @default(auto()) @map("_id") @db.ObjectId
  testId              String   @unique @map("test_id") @db.ObjectId
  test                Test     @relation(fields: [testId], references: [id])
  requireRegistration Boolean  @default(false) @map("require_registration")
  inputFields         Json?    @map("input_fields")
  requiredFields      Json?    @map("required_fields")
  showDetailedResults Boolean  @default(false) @map("show_detailed_results")
  timeLimit           Int?     @map("time_limit")
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")

  @@map("test_settings")
}

model Test {
  id            String           @id @default(auto()) @map("_id") @db.ObjectId
  authorId      String           @map("author_id") @db.ObjectId
  author        User             @relation("TestAuthor", fields: [authorId], references: [id])
  title         String           @map("title")
  description   String?          @map("description")
  status        ModerationStatus @default(PENDING) @map("status")
  totalAttempts Int              @default(0) @map("total_attempts")
  questions     Question[]
  settings      TestSettings?
  testAttempts  TestAttempt[]
  createdAt     DateTime         @default(now()) @map("created_at")
  updatedAt     DateTime         @updatedAt @map("updated_at")

  @@map("tests")
}

model Question {
  id          String       @id @default(auto()) @map("_id") @db.ObjectId
  testId      String       @map("test_id") @db.ObjectId
  test        Test         @relation(fields: [testId], references: [id])
  text        String       @map("text")
  order       Int          @map("order")
  type        QuestionType @default(SINGLE_CHOICE) @map("type")
  answers     Answer[]
  userAnswers UserAnswer[]
  createdAt   DateTime     @default(now()) @map("created_at")
  updatedAt   DateTime     @updatedAt @map("updated_at")

  @@map("questions")
}

model Answer {
  id          String       @id @default(auto()) @map("_id") @db.ObjectId
  questionId  String       @map("question_id") @db.ObjectId
  question    Question     @relation(fields: [questionId], references: [id])
  text        String       @map("text")
  isCorrect   Boolean      @default(false) @map("is_correct")
  isGenerated Boolean      @default(false) @map("is_generated")
  userAnswers UserAnswer[]
  createdAt   DateTime     @default(now()) @map("created_at")
  updatedAt   DateTime     @updatedAt @map("updated_at")

  @@map("answers")
}

model TestAttempt {
  id          String            @id @default(auto()) @map("_id") @db.ObjectId
  testId      String            @map("test_id") @db.ObjectId
  test        Test              @relation(fields: [testId], references: [id])
  userId      String?           @map("user_id") @db.ObjectId
  user        User?             @relation("TestAttemptUser", fields: [userId], references: [id])
  userData    Json?             @map("user_data")
  score       Float?            @map("score")
  startedAt   DateTime          @default(now()) @map("started_at")
  completedAt DateTime?         @map("completed_at")
  status      TestAttemptStatus @map("status")
  answers     UserAnswer[]
  createdAt   DateTime          @default(now()) @map("created_at")
  updatedAt   DateTime          @updatedAt @map("updated_at")

  @@map("test_attempts")
}

model UserAnswer {
  id         String      @id @default(auto()) @map("_id") @db.ObjectId
  attemptId  String      @map("attempt_id") @db.ObjectId
  attempt    TestAttempt @relation(fields: [attemptId], references: [id])
  questionId String      @map("question_id") @db.ObjectId
  question   Question    @relation(fields: [questionId], references: [id])
  answerId   String      @map("answer_id") @db.ObjectId
  answer     Answer      @relation(fields: [answerId], references: [id])
  answeredAt DateTime?   @map("answered_at")
  timeSpent  Int?        @map("time_spent")
  createdAt  DateTime    @default(now()) @map("created_at")

  @@map("user_answers")
}

model BadWord {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  word      String   @unique @map("word")
  addedById String   @map("added_by_id") @db.ObjectId
  addedBy   User     @relation("AddedByUser", fields: [addedById], references: [id])
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("bad_words")
}

enum Role {
  USER
  ADMIN
}

enum ModerationStatus {
  PENDING
  APPROVED
  REJECTED
}

enum TestAttemptStatus {
  EXPIRED
  IN_PROGRESS
  COMPLETED
}

enum QuestionType {
  SINGLE_CHOICE
  MULTIPLE_CHOICE
}
